---
title: Luty
layout: post
category: links
description: |
    W rozwoju osobistym sporo o lęku przed porażką i niepróbowaniu.
    W praktyce programowania o samym procesie wytwarzania oprogramowania, o programowaniu w stylu lean i BDD.
    Do tego ciekawostki o czcionkach i jeszcze parę innych drobiazgów w różnych sekcjach.
    To wszystko w linkach z lutego!
---




Biznes
---

Ponoć wychodzi jakoś teraz w Polsce biografia Elona Muska.
Dla tych, co tego pana nie znają, a także dla ciekawskich, artykuł z Wyborczej: [Elon Musk - geniusz czy szaleniec? Twórca PayPala, Tesli, SpaceX zmusza podwładnych do pracy ponad siły](http://weekend.gazeta.pl/weekend/1,138262,19611935,elon-musk-geniusz-czy-szaleniec-tworca-paypala-tesli-spacex.html).
Sam jestem ciekaw, ile jest prawdy w doniesieniach o pracoholizmie Muska i o tym, jak bardzo jest wymagający i skoncentrowany na swoich przedsięwzięciach.
Coś w tym może być, skoro informacje o tym pojawiają się tak często, i skoro sam Musk osiąga tak spektakularne sukcesy.
Dla tych, którzy chcą dowiedzieć się więcej, pytanie na Quora: [How did Elon Musk work for 100 hours a week for more than 15 years?](https://www.quora.com/How-did-Elon-Musk-work-for-100-hours-a-week-for-more-than-15-years)

Zresztą o tym jak skrajnymi postaciami są niektórzy _founders_, w mediach aż dudni.
Musk, czyli pracoholik, Jobs to neurotyk, a Gates to nerd (choćby ostatnio z InnoPoland: [Bill Gates miał obsesję! 2 tygodnie jednocześnie programował i spał nad klawiaturą. Tak powstał Microsoft](http://innpoland.pl/124749,bill-gates-mial-obsesje-2-tygodnie-jednoczesnie-programowal-i-spal-nad-klawiatura-tak-powstal-microsoft)).
I tak dalej, choć nie wiadomo, na ile ci ludzie faktycznie tacy są, na ile to autokreacja, a na ile samonakręcające się media.

Ostatnio czytam książkę Petera Thiela i Blake Mastersa, _Zero to one_, w której jest rozdział poświęcony temu zjawisku -- dlaczego i na ile biznesmeni są tacy _wyjątkowi_.
A ponieważ książka powstała na podstawie bloga Blake Mastersa, który powstał na podstawie wykładów Petera Thiela, odsyłam do bloga, gdzie znajdziecie z grubsza to, co w książce: [Founder as Victim, Founder as God](http://blakemasters.com/post/24578683805/peter-thiels-cs183-startup-class-18-notes).

---

W [styczniu](http://dzikowski.github.io/links/2016/01/31/styczen/) pisałem tzw. _stack fallacy_, w którym jako jeden z przykładów podałem to, że Apple potrafi robić świetny sprzęt, ale z oprogramowaniem wcale tak dobrze im nie idzie.
W lutym natknąłem się na wpis [Apple’s declining software quality](http://sudophilosophical.com/2016/02/04/apples-declining-software-quality/), w którym możesz znaleść przykłady.
Fajna jest też dyskusja o tym wpisie na [Hacker News](https://news.ycombinator.com/item?id=11034071).
Pokazuje różne punkty widzenia -- że to jest problem związany z zarządzaniem, albo że to kwestia percepcji, bo oprogramowanie Apple od zawsze było _buggy_, albo że to nie ma znaczenia, bo mimo że jest _buggy_, daje nam fajne funkcjonalności.
W każdym razie jakoś niespecjalnie widać, żeby ktoś zaprzeczał ;-)

---

W styczniu pisałem też o GitHubie i o liście otwartym twórców oprogramowania Open Source, którego przesłanie brzmiało: _ogranijcie się, nie jesteście dość dobrzy_.
W lutym w związku z tym (albo bez związku, albo w związku jeszcze z [czymś innym](https://github.com/blog/2106-january-28th-incident-report)) pojawiło się kilka artykułów krytycznych.
[Business Insider](http://www.businessinsider.com/github-identity-crisis-2016-2) pisał o napięciach wewnątrz firmy, niektórzy wychwalali GitLaba ([Choose GitLab for your next open source project](https://www.b.agilob.net/choose-gitlab-for-your-next-project/)), pisząc o tym, w czym jest lepszy od GitHuba, a inni jeszcze deklarowali przeniesienie własnych projektów do konkurencji.

Nic jednak wielkiego się nie stało, żaden z wielkich projektów nie zmienił miejsca trzymania źródeł.
Szum minął, a GitHub być może lekko się zatrząsł i dalej idzie do przodu.
Na początek wprowadzili jedną z funkcjonalności, której się domagano: [Issue and Pull Request templates](https://github.com/blog/2111-issue-and-pull-request-templates).

---

Oczywiście nie mogło też zabraknąć historii o startupach.
W tym miesiącu o tym, jak się reklamować, nie mając zbytnio na to budżetu: [How we got our first 100 paying customers](https://www.stackfield.com/blog/how-we-got-our-first-100-paying-customers-33).




Rozwój osobisty
---

Skoro była już mowa już o Musku, to w lutym czytałem też artykuł na LinkedIn, do którego przyciągnęło mnie między innymi jego nazwisko: [I asked Larry Page, Elon Musk and Jack Dorsey how they felt starting their companies. Their answers caught me off guard](https://www.linkedin.com/pulse/overcome-fear-failure-instead-adam-grant).
Adam Grant, autor artykułu, opisuje to, czego dowiedział się od wspomnianych Przedsiębiorców, kiedy robił z nimi wywiady do swojej książki.
Twierdzi, że:

> They all felt the same fear of failure that the rest of us do. They just responded to it differently.

Wyszło na to, że i tutaj pojawia się znany motyw związany z tym, że ludzie chcą poczuć się bezpiecznie, dlatego nie próbują czegoś nowego.
Tymczasem okazuje się, że najczęściej żałuje się nie tego, że się coś zrobiło, ale tego, że się czegoś nie zrobiło.
Musk, Page i Brin, Dorsey (_ten od Twittera_), Jobs, Cuban (_ten od Ubera_) ponosili porażki i próbowali dalej.
Jobs przecież został wyrzucony ze swojej firmy, Page i Brin z niepowodzeniem próbowali kiedyś sprzedać Googla, a Cuban ma za sobą startup, który nie wypalił.
Grant twierdzi, że wszyscy ci Przedsiębiorcy bardziej bali się nie spróbować, niż spróbować i ponieść porażkę.

Oczywiście _jeśli nie będziesz ciągle próbować, to ci się nie uda_ to truizm i potworne uproszczenie, jednak warto się zastanowić trochę głębiej nad tym, że obawa przed porażką jest niewspółmiernie duża w porównaniu do potencjalnych konsekwencji faktycznej porażki.

Można na przykład twierdzić, że jest to niejako uwarunkowane ewolucyjnie, kiedy porażki miały dramatyczne konsekwencje (np. zjadł cię tygrys szablozębny), albo że chodzi tutal o jakiegoś rodzaju błąd poznawczy w stylu [niechęci do straty](https://pl.wikipedia.org/wiki/Niech%C4%99%C4%87_do_straty) (a zresztą pewnie jedno i drugie i tak są ze sobą powiązane).
Albo że chodzi o skłonność do ryzyka wbudowaną w geny -- Amerykanie mogą uchodzić za naród najbardziej przedsiębiorczy dlatego, że większość z nich ma przodka, który podjął ryzyko emigracji na drugą stronę Atlantyku.

Moim zdaniem jednym z ważnych czynników _przesadnego_ lęku przed porażką jest konstrukcja systemu edukacji, który mniejszy nacisk kładzie się na wspieranie eksploracji, a większy na zwalczenie potknięć.
Mamy przecież od pierwszej klasy do końca studiów taki system, w którym wykładowca/nauczyciel _podaje_ jedynie słuszną wiedzę, a następnie _sprawdza_, na ile wiedza została zapamiętana i _karze_ za popełnione błędy, wystawiając niższą ocenę.

Maciej Bennewicz, znany polski coach, pisze w swojej książce (_Coaching, czyli restauracja osobowości_):

> Niestety już od pierwszej klasy wbija się nam negatywne przekonania.
> Nauczyciel podkreśla czerwonym długopisem błędy.
> W ten sposób je w nas "wdrukowuje" łącznie z przekonaniem, że "jestem słabym uczniem".
> Słabymi uczniami byli Einstein, Edison, Churchil i setki innych!
> Podobne nawyki mają nasi szefowie i my wobec siebie samych, członków rodzin właśnych dzieci!

Albo Michał Pasterski pisał na swoim blogu o schemacie _popełnianie błędów jest złe_ ([13 błędów polskiego systemu edukacji](http://michalpasterski.pl/2014/04/13-bledow-polskiego-systemu-edukacji/)):

> Już od pierwszej klasy szkoły podstawowej dzieci są ofiarami polityki strachu, według której nauczyciele traktują popełnianie błędów jako oznakę bycia “gorszym uczniem”.
> 
> Taki sposób myślenia niszczy kreatywność dzieci i buduje u nich stałe poczucie strachu przed podejmowaniem działań i eksperymentowaniem.
> To w większości przypadków na zawsze kształtuje psychikę człowieka i jest jednym z najważniejszych powodów, dla których tak wielu z nas żyje przeciętnym życiem.

Bo to już nie jest tylko kwestia tego, czy stworzysz _startup_, który osiągnie sukcesy, tylko coś znacznie większego.


---

No dobra, ale ciągnąc dalej wątek _chcenia_ i _robienia_.
Jessica Abel (amerykańska artystka i twórczyni komiksów) opisuje na swoim blogu pojęcie **[_Idea Debt_](http://jessicaabel.com/2016/01/27/idea-debt/)**.
Pojęcie jest zapożyczone od Kazu Kibushi (japońskiego twórcy komiksów) który powiedział:

> I try not to to look at what I’m going to do as this amazing great grand thing.
> (...)
> Now I’m actually solving problems in the moment, and that’s so much more exciting than than trying to fill years of what I like to call my “idea debt.”
> That’s when you have this dream of this awesome thing for years.
> You think, “Oh, I’m going to do this epic adventure. It’s going to be so great.”
> The truth is, no matter what you do, it will never be as great as it is in your mind, and so you’re really setting yourself up for failure.

_Idea Debt_ jest wtedy, kiedy myślisz dużo o czymś wspaniałym, co zrobisz, opowiadasz o tym znajomym, ale tak właściwie niewiele robisz.
Masz jakiś swój projekt, na który wpadłeś kilka lat temu, zbierasz pomysły, zastanawiasz się, jak do niego podejść i jaki wspaniały będzie rezultat.
Wtedy, tłumacząc prawie dosłownie, _zaciągasz dług wobec swojego pomysłu_.
Ten dług rośnie z czasem, kiedy pomysł wydaje ci się coraz lepszy i pewnie warto zacząć realizację, zanim będzie nie do spłacenia.
Warto spróbować, zanim zdąży urosnąć.

Ale oczywiście tylko, jeśli chcesz zrealizować swój pomysł.
Bo może nie chcesz, może nie warto, a nikt ci nie karze i [nikt nie ma prawa od ciebie oczekiwać](https://medium.com/@jamievaron/to-anyone-who-thinks-they-re-falling-behind-f194afde9148#.nf7wbka2u), żeby twoja wspaniała idea się zmaterializowała.

I to też taką przestrzeń (w angielskim słowo _space_ ładnie pasuje), bo nikt nie będzie do ciebie miał pretensji, jak ci się nie uda.

---

Teraz krótko o pracy zdalnej.
Jedną z firm, która pracuje w znacznej mierze zdalnie jest [Basecamp](https://basecamp.com) (swoją drogą Basecamp wydało nawet [książkę](http://www.amazon.com/Remote-Office-Required-Jason-Fried/dp/0804137501?ie=UTF8&*Version*=1&*entries*=0) o pracy zdalnej).
Jason Zimdars, jeden z tamtejszych designerów we wspisie [Why I work remotely (hint: it has nothing to do with productivity)](https://m.signalvnoise.com/why-i-work-remotely-hint-it-has-nothing-to-do-with-productivity-34ace30f74fc?gi=5f05e45b5e26) podaje kilka zalet z obszaru życia osobistego.
Można podczas pracy opiekować się chorym dzieckiem, można na tydzień pracować u przyjaciela, w ciągu dnia wyprowadzić psa itd.

(Na marginesie: od marca zaczynam pracować w pełni zdalnie!)

<img src="https://cdn-images-1.medium.com/max/1200/1*R8M5hRIV1y9aQcvjJe5PTQ.jpeg" style="max-width: 480px;">



Praktyka programowania
---

> TL:DR You can not observe a developer without altering their behavior.

Tak na samym początku artykułu [Heisenberg Developers](http://mikehadlow.blogspot.co.uk/2014/06/heisenberg-developers.html) pisze Mike Hadlow.
Jest to artykuł jeszcze z czerwca 2014, jednak natknąłem się na niego na HackerNews w lutym tego roku.

Mike Hadlow zaczyna od historii.
Kilka lat temu pracował w firmie, gdzie wszystko szło gładko, jednak z czasem pojawiło się wymaganie klienta, które na początku wydawało się nieskomplikowane, jednak z czasem okazało się straszną kobyłą.
Developerzy chcieli odłożyć implementację na później, na którąć z kolejnych wersji systemu, ale biznes nalegał.

Po kilku miesiącach, kiedy ciągle nie było widać końca implementacji, biznes zdecydował się na zatrudnienie menadżera ze świetnym CV.
Zacieśniono kontrolę -- wprowadzono Jirę.
Każda funkcjonalność była rozbijana na mniejsze zadania wpisywane do Jiry.
Każda próba refaktoringu musiała być udokumentowana.

Wszystko zwolniło.
Programiści zamiast rozwijać aplikację, zaczęli realizować _taski_.
Dla własnego bezpieczeństwa zawyżali _estymaty_.
Motywacja spadła.
W końcu najlepsi ludzie, także autor, odeszli z firmy.

No więc co poszło nie tak?
Mike Hadlow podaje kilka przykładów:

  * Proces wytwarzania oprogramowania nie jest do końca rozumiany przez menadżerów. Często traktowany jest jako zestaw mechanicznych czynności, a nie proces twórczy.
  * Próbowano wymusić estymację, co w przypadku wytwarzania oprogramowania jest możliwe tylko w bardzo ograniczonym zakresie.
  * Bardzo szczegółowe zarządzanie (mikrozarządzanie) prowadzi do tego, że najbardziej utalentowane osoby odchodzą (piękne zdanie: _Finely grained management is a recipe for "talent evaporation"_).

A receptą na to wszystko jest autonomia.

(Koniecznie poczytajcie też komentarze do tamtego wpisu).

---

Na blogu o znamiennej nazwie _programming is terrible_ w lutym pojawił się wpis [Write code that is easy to delete, not easy to extend](http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to).
Jest to świetny wpis o tym, jak należy programować -- krok po kroku.
A całość zaczyna się cytatem Jeana Paula Sartre'a z czasów przed jego karierą filozoficzną, kiedy jeszcze programował w ANSI C ([link](https://news.ycombinator.com/item?id=11098491) dla niedowiarków):

> Every line of code is written without reason, maintained out of weakness, and deleted by chance.

Każda istniejąca linijka kodu wiąże się z kosztem utrzymania.
Im więcej masz linijek, tym więcej będziesz musiał włożyć wysiłku, jeśli coś się zmieni.
Dlatego warto pisać taki kod, który łatwo jest usunąć.

(Poniżej synteza listy kroków, ale jeśli tylko potrafisz czytasz po angielsku, zajrzyj na oryginalny wpis, bo tutaj będzie mało przykładów i sporo uproszczeń).

 0. **Nie pisz kodu**.
    Trudniej utrzymać monolit z milionem linijek niż mikroserwis, gdzie linijek jest kilkadziesiąt.
    Usunięcie jednej linijki w monolicie da mniejszy efekt, niż usunięcie linijki w mikroserwisie.
 1. **Kopiuj kod**, bo wykorzystanie kilka razy kawałka kodu, daje sporo korzyści -- możesz na przykład zobaczyć, jak ten kawałek jest dostosowywany do konkretnych rzeczy w twoim kodzie.
    Jeśli jednak zrobisz z tego kawałka np. osobną, współdzieloną funkcję, trudniej będzie utrzymać twój kod.
    Łatwiej zmienić skopiowany kod wewnątrz funkcji, niż zmienić współdzieloną funkcję.
    (Zajrzyj też [tutaj](http://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction)).
 2. **Nie kopiuj kodu**, czyli innymi słowy: twórz _utils_.
    Jeśli coś zaczynasz kopiować często, albo coś korzysta z informacji ze _świata zewnętrznego_ (plików konfiguracyjnych, zmiennych środowiskowych, systemu plików), stwórz folder _util_ i wrzucaj tam pliki implementujące te często powtarzające się rzeczy.
    W tym wypadku jednak, zamiast robić coś _easy-to-delete_, dążymy do tego, żeby te rzeczy, które trudno usunąć, trzymać w jednym miejscu.
 3. **Pisz więcej _boilerplate_**, czyli takiego _copy-paste_ kodu, w którym za każdym razem trochę się zmienia.
    Przykład: skorzystanie z biblioteki do zapytania HTTP, gdzie tworzy się zapytanie, wykonuje je, a potem czeka na odpowiedź.
    Tutaj podobnie jak w kopiowaniu kodu chodzi o to, żeby minimalizować zależności do czegoś, co jest poza danym _scope_ (funkcją, metodą, klasą itp.).
 4. **Nie pisz _boilerplate_**, jeśli zduplikowanego kodu jest zbyt dużo.
    Często powstają biblioteki, które są _nakładką_, fasadą na bardziej skomplikowaną bibliotekę, a dzięki którym sam nie musisz pisać tyle _boilerplate_.
    Korzystaj z nich, jeśli trzeba, albo stwórz swoje (choćby w formie _utils_).
 5. **Stwórz wielki kawał kodu**, czasami trzeba.
    Dzień się kończy, a ty masz za mało czasu, żeby skończyć funkcjonalność zgodnie z dobrymi praktykami.
    Albo tworzysz startup i nie masz czasu napisać czegoś zgodnie ze sztuką (tzw. _founders code_).
    Dobrze, napisz wielką metodę, pełną zagmatwanego kodu, ale niech wszystko będzie w jednym miejscu.
    Łatwiej będzie taki kod usunąć w przyszłości.
    Łatwiej usunąć jeden wielki problem, niż 18 malutkich, współzależnych, które powstały, kiedy pochopnie dzieliłeś swój kod.
 6. **Podziel swój kod na mniejsze kawałki**, bo duże fragmenty kodu łatwo usunąć w całości, ale trudno usunąć tylko część z nich.
    Kod powinien być podzielony nie przez wzgląd na funkcjonalności, ale przez to, na ile jest niezależny.
    Utrzymywanie dwóch różnych funkcjonalności w jednym komponencie może być OK, jeśli ich podzielenie może spowodować konieczność nietrywialnej koordynacji powstałych po podzieleniu.
    No i oczywiście używaj _loose coupling_.
    Klocki, z których budujesz swój system powinno się dać łatwo podmienić.
 7. **Dalej pisz kod**, ale taki, który łatwo jest usunąć.
    Jeśli piszesz kod, który jest rozszerzalny, zakładasz, że za trzy miesiące wszystko się ładnie zgra.
    Jeśli piszesz kod, który łatwo jest usunąć, na bieżąco możesz eksperymentować, zostawiać to, co działa i pozbywać się nietrafionych eksperymentów.

---

Można powiedzieć, że w [Write code that is easy to delete, not easy to extend](http://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to) zostało opisane takie _lean-podejście_ do pisania kodu -- eksperymentuj i wycofuj się w razie potrzeby, i nie zaczynaj od robienia czegoś wielkiego.
Podobne podejście można znaleźć we wpisie [Strategic Scala Style: Principle of Least Power](http://www.lihaoyi.com/post/StrategicScalaStylePrincipleofLeastPower.html).
Wszystko po to, żeby uniknąć nadmiernego skomplikowania kodu.
Ogólna zasada brzmi:

> Given a choice of solutions, pick the least powerful solution capable of solving your problem.

A filozofia, która sie za tym kryje jest prosta.
Złożoność to twój wróg, nie bój się refaktorować i uważaj, żeby nie przekombinować (_don't over engineer_).

Mając to wszystko na uwadze, autor przeprowadza nas po kolei przez takie zagadnienia, jak _immutability_, interfejsy, typy danych, obsługa błędów, asynchroniczne typy danych i wstrzykiwanie zależności.
Wszystko pięknie, na przykładach i krok po kroku.

---

Na koniec tej sekcji jeszcze o testowaniu i BDD.

Ostatnio (dokładnie nie pamiętam, ale chyba jeszcze w styczniu) byłem w Krakowie na Meetupie poświęconym BDD i Spock.
Jedna z myśli, która tam padła, dotyczyła tego, że BDD często jest przeformalizowane i wymaga mnóstwo nadmiarowego kodu.
Pisząc np. w JBehave, mnóstwo rzeczy trzeba skonfigurować, zaprogramować parsowanie i wykonanie (po wyrażeniach regularnych) każdego wyrażenia z Gherkina; innymi słowy, mnóstwo dodadkowego kodu do utrzymania.
A w dodatku okazuje się, że składnia Gherkina miała być czytelna dla klientów, ale kiedy takich opisów testów jest sporo, klient nie chce tego czytać.
Czyli mamy narzędzie, albo sposób testowania, który powstał dla biznesu, ale okazuje się, że biznes tego nie potrzebuje, a programiści muszą utrzymywać więcej kodu.

Taki był punkt wyjścia tego spotkania, ale oczywiście wskazana została jedna wielka zaleta Gherkina -- wykorzystanie jego składni (dla przypomnienia: _given/when/then_) i samo zastosowanie BDD bardzo dobrze strukturyzuje testy.
Tutaj wkroczył na scenę [Spock](https://github.com/spockframework), czyli framework do testowania w Groovym (działa na JVM), w którym można robić BDD, bez konieczności utrzymywania plików w składni Gherkina.
Wszystko wraca na swoje miejsce, robimy BDD w sposób mniej obciążający programistów i równie czytelny, a biznesowi możemy pokazać kilka testów akceptacyjnych.

<img src="http://www.themarysue.com/wp-content/uploads/2015/04/Mr-Spock-mr-spock-10874060-1036-730.jpg" style="max-width: 480px;"/>



DevOps
---

Obecnie w adresach stron internetowych przedrostek `www` często jest pomijany.
Dlaczego nie jest to najlepsza praktyka, przeczytacie na stronce [www. is not deprecated](http://www.yes-www.org/why-use-www/).

---

[CloudFlare](https://www.cloudflare.com/) to ciekawe narzędzie służące do poprawy wydajności aplikacji i portali internetowych.
Z jednej strony to taki [_CDN_](https://pl.wikipedia.org/wiki/Content_Delivery_Network), ale z drugiej ma sporo zaawansowanych opcji, zabezpieczających nawet przed DDOS.
Konfiguracja jest banalnie prosta -- żeby zacząć wystarczy zmienić swoje DNSy i... to wszystko.
CloudFlare, będzie teraz _cache'ować_ twoje skrypty i CSSy.

Jeśli chcesz dowiedzieć się, jak to działa, zajrzyj [tutaj](https://www.quora.com/How-does-CloudFlare-work).
I wspomnij mój wpis, jeśli natkniesz się na taką stronkę:

<img src="/assets/img/posts/cloudflare.png" style="max-width: 480px;">

---

Nieciekawa historia z wpisu [Today DigitalOcean lost our entire server](https://murze.be/2016/02/today-digitalocean-lost-our-entire-server/) przypomina, że nie warto do końca ufać nawet wyspecjalizowanym firmom i najlepiej samemu sobie robić dodatkowe _backupy_.

---

I jeszcze na koniec dobre praktyki SSH: [SSH: Best practices](https://blog.0xbadc0de.be/archives/300).


Architektura i narzędzia
---

W tej sekcji niewiele, tylko jedno narzędzie.
Ponieważ mam już trochę dość cukierkowego Bootstrapa i błyskawicznie zmieniającego się Google Web Starter Kit, więc podaję lżejszą alternatywę, której pewnie spróbuję w najbliższym czasie: [Basscss](http://www.basscss.com/).


Ciekawostki
---

Pierwszy artykuł z ciekawostek jest o kerningu czcionek ([A Beginner’s Guide to Kerning Like a Designer](https://designschool.canva.com/blog/kerning/)), czyli regulowaniu odległości w czcionkach pomiędzy poszczególnymi znakami.
Szczerze mówiąc, to dopiero teraz się dowiedziałem, czym kerning jest i że w ogóle jest potrzebny.

Drugi artykuł też o czcionkach!
[The New Web Typography](https://robinrendle.com/essays/new-web-typography/) to dosyć długi wpis o tym, jak współcześnie powinny wyglądać czcionki na stronach internetowych, jakie są z tym problemy itp.
Choć są tam fragmenty techczniczne i wskazówki, znacznie bardziej jest to esej niż tutorial.

---

We wpisie [Graphing when your Facebook friends are awake](https://defaultnamehere.tumblr.com/post/139351766005/graphing-when-your-facebook-friends-are-awake) pewien developer opisał, jak na podstawie informacji o statusach znajomych w czacie Facebookowym, wywnioskował, kiedy znajomi śpią, a kiedy nie.
Wnioskowanie okazało się całkiem trafne i daje do myślenia o tym, jak wiele można się o nas dowiedzieć z Facebooka.

---

Jeśli korzystaliście z Maca, to pewnie wiecie, że instalacja aplikacji polega tam na tym, że pobiera się jakiś plik, rozpakowuje go, a następnie przenosi go do folderu Aplikacje.
Zwykle pliki te są dość duże -- 100&nbsp;MB to takie minimum.
Dzieje się tak dlatego, że aplikacja na maca zawiera wszystkie zależności, jakich potrzebuje i uruchamiana jest w środowisku izolowanym od reszty zależności.
Np. nie wysypie się, bo zainstalowana w systemie bilioteka X jest w nieodpowiedniej wersji.

Ostatnio pojawiło się narzędzie, które umożliwia instalowanie aplikacji w taki sposób na linuksach: [AppImage](http://appimage.org/).

---

OK, każdy to gdzieś już widział, ale ja też zamieszczę: w lutym [Typesafe zmieniło nazwę](https://www.lightbend.com/blog/typesafe-changes-name-to-lightbend)!




