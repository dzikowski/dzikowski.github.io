---
title: Continuous Deployment w Gitlabie
layout: post
description: |
    Jak pewnie połowa programistów, prowadzę swoje małe projekciki, które być może kiedyś podbiją świat.
    Postanowiłem skonfigurować dla nich proces <em>Continuous Deployment</em> z wykorzystaniem Gitlaba.
    W tym poście napisałem trochę o <em>Continuous Integration</em>, <em>Delivery</em> i <em>Deployment</em>, a potem pokazałem, w jaki sposób zrobiłem to dla jednego z moich projektów.
---

Do tej pory korzystałem z BitBucket, którego główną korzyścią (dla mnie) były darmowe prywatne repozytoria (na GitHhubie taka przyjemność kosztuje 7 dolarów miesięcznie).
Jeśli chodzi o hosting i wdrażanie, to korzystałem z różnych rozwiązań.
Kiedyś z Heroku (świetne na demo, drogie dla wersji produkcyjnych), potem z Dokku na własnym serwerze od Digitalocean (w rozsądnej wersji 10 dolarów miesięcznie).
Jedną aplikację mam na Google App Engine, a inną wrzucam bezpośrednio na VPS (przez SCP).

Dla Heroku i Dokku _Continuous Deployment_ jest proste.
Po prostu wrzucam zmiany do repozytorium do _master branch_ i na serwerze wywoływane jest budowanie aplikacji, a zbudowana aplikacja staje się wersją produkcyjną.
W Google App Engine to kwestia wywołania dodatkowego polecenia, które wrzuca nową wersję aplikacji na serwer.
Wrzucanie przez SCP jest podobnie pracochłonne, a pewnie przeczy większości dobrych praktyk.

Z kolei w firmie, dla której obecnie pracuję, korzystam z Jenkinsa, co jest świetnym rozwiązaniem, ale wymagającym dużego zaangażowania i konfiguracji (zarządzanie użytkownikami, osobny serwer, połączenie z systemem kontroli wersji i tak dalej).
W związku z tym wszystkim postanowiłem wypróbować coś nowego, Gitlab, który _out of the box_ może dać mi wersjonowanie na Gicie, wbudowany mechanizm CI, _issue tracker_, _code reviews_ i inne ciekawe rzeczy.


_Continuous Integration_, _Delivery_ i _Deployment_
---

Ale zacznijmy od początku.
Pewnie kojarzysz te trzy pojęcia: _Continuous Integration_, _Continuous Delivery_ i _Continuous Deployment_.
Każde z nich znaczy coś trochę innego, ale wszystkie związane są z tym, że proces budowania systemu wywoływany jest automatycznie i często.

![Agile vs iterative](http://blog.martinfenner.org/images/Agile-vs-iterative-flow.jpg)

<p style="text-align:right"><a href="http://blog.martinfenner.org/images/Agile-vs-iterative-flow.jpg">Źródło obrazka</a></p>

Jeśli często wrzucasz zmiany na produkcję, to na pewno te zmiany są mniejsze, niż gdybyś wrzucał je rzadko.
Tym samym trudniej jest coś zepsuć i mniejsze ryzyko, że coś pójdzie nie tak.

Bardzo ważna jest też, jak wspominał niedawno na jednym ze [spotkań](http://evenea.pl/imprezy/biznes-i-przedsiebiorczosc/krakow/microservices--jaroslaw-palka--it-akademia-j-labs-103809/) Jarosław Pałka, możliwość odwrócenia zmian.
Jeśli się okaże, że nowa wersja aplikacji nie działa tak, jak powinna, trzeba cofnąć te zmiany.
I tutaj znów korzystniejsze jest częstsze wypuszczanie wersji, bo łatwiej jest odwrócić mniejsze zmiany niż większe.
A jeśli jeszcze wdrożenie systemu wymaga jakiejś dodatkowej konfiguracji, ustawiania zmiennych środowiskowych, plików konfiguracyjnych, czyli tego, na co wszystkie _Continuous (...)_ patrzą bardzo niechętnie, to życzę szczęścia w odwracaniu dużych zmian -- na pewno będzie potrzebne.


Tak jak wspominałem, mamy trzy podstawowe pojęcia: _Continuous Integration_, _Continuous Delivery_ i _Continuous Deployment_.
Pierwsze z nich oznacza częste włączanie zmian kodu źródłowego do głównego repozytorium, a najczęściej także automatyczne uruchamianie testów w jakimś zewnętrznym środowisku, np. na Jenkinsie.
Dzięki temu można uniknąć sytuacji, kiedy okazuje się, że po miesiącu pracy wrzucamy do repozytorium kod, a po kolejnym miesiącu, kiedy chcemy uruchomić aplikację, okazuje się że ten kod nie współpracuje dobrze z innymi komponentami systemu i spędzamy tydzień, żeby ten problem naprawić.
Ciągle integrujemy, czyli na bieżąco -- i automatycznie -- sprawdzane jest, czy nasze zmiany dobrze współdziałają z całością systemu.

Kolejne dwa pojęcia: _Continuous Delivery_ i _Continuous Deployment_ bywają często mylone.
Różnicę pomiędzy nimi dobrze pokazuje ten obrazek ([źródło](http://blog.crisp.se/wp-content/uploads/2013/02/continuous-delivery-deployment-sm.jpg)):

![Delivery vs deployment](http://blog.crisp.se/wp-content/uploads/2013/02/continuous-delivery-deployment-sm.jpg)

Czyli podstawową różnicą jest to, czy na produkcyjną wersję aplikacji zmiany wrzucane są automatycznie, czy też manualnie.
W _Continuous Delivery_ mamy do dyspozycji szereg kolejnych wersji, które przeszły testy i są gotowe na wrzucenie na środowisko produkcyjne.
Mamy też kogoś, kto w razie potrzeby bierze którąś z tych wersji i wrzuca ją na to środowisko.

W przypadku _Continuous Deployment_, kiedy w _master branch_ lądują zmiany, automatycznie uruchamiane są testy, aplikacja jest budowana i wrzucana na środowisko produkcyjne.
Albo np. to automatyczne wrzucanie na środowisko produkcyjne odbywa się zgodnie z jakimś ustalonym harmonogramem.

Ja na potrzeby mojej aplikacji chciałem skonfigurować właśnie _Continuous Deployment_, kiedy mój _commit_ do _master branch_ powoduje wrzucenie zmian na środowisko produkcyjne. (Przepraszam za zagęszczenie kolokwializmów, ale co w angielskim brzmi naturalnie, w polskim często nie ma odpowiedników...).

Zanim jednak przejdę do mojego procesu, chciałbym polecić kilka linków.
Po pierwsze, [lista dobrych praktyk](https://en.wikipedia.org/wiki/Continuous_integration#Best_practices) _Continuous Integration_ z anglojęzycznej Wikipedii.
[Słowniczek](https://about.gitlab.com/2015/05/18/simple-words-for-a-gitlab-newbie/) z bloga Gitlaba, opisujący różne pojęcia, które w CI/CD są często używane, a także pojęcia, które będą ważne z punktu widzenia pracy z Gitlabem.
Przyda się, jeśli jeszcze nie pracowałeś z Githubem, Bitbucket, Gitlabem, albo inną tego rodzaju platformą.
I jeszcze jeden [artykuł](https://about.gitlab.com/2015/02/03/7-reasons-why-you-should-be-using-ci/) z bloga Gitlaba, o tym, dlaczego powinieneś używać _Continuous Integration_.



Narzędzia
---

Do tej pory w swojej karierze korzystałem z kilku narzędzi do _Continuous Integration_, _Delivery_, czy _Deployment_.






Siermiężne

Skomplikowana konfiguracje






Gitlab
---



Gitlab CI
---

http://doc.gitlab.com/ce/ci/quick_start/README.html


Na tym samym serwerze: https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/gitlab-ci/README.md









Gitlab runner
    https://about.gitlab.com/gitlab-ci/


Instalacja runnera na dockerze: https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/install/linux-repository.md

Security: https://gitlab.com/gitlab-org/gitlab-ci-multi-runner/blob/master/docs/security/index.md




https://github.com/gliderlabs/docker-alpine


Git-Auto-Deploy
---



Mój proces
---

Git -> Gitlab -> runner -> apache





Bezpieczeństwo mojego procesu
---

Serwer apache musi być pull



Łatwość konfiguracji
---





